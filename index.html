<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rizz System â€” Version 1 + Screenshot Rizz</title>

<!-- Tesseract.js (client-side OCR) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>

<style>
:root{
  --bg:#000; --fg:#fff; --muted:#8c8c8c; --accent:#00d18a; --pill:#222; --warn:#ffb300;
  --card:#0b0b0b;
}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
.wrap{max-width:980px;margin:18px auto;padding:16px}
h1 { font-size:28px; margin:0 0 8px; }
.headerNote{color:var(--muted); font-size:13px; margin-bottom:12px}

.controls{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}
.inputText{flex:1;padding:12px;border-radius:12px;border:0;background:#111;color:var(--fg);font-size:16px}
.btn{padding:10px 14px;border-radius:12px;border:0;background:#e9eef5;color:#0a2b4f;font-weight:700;cursor:pointer}
.small{padding:8px 10px;font-size:14px}
.banner{display:none;background:var(--warn);color:#000;padding:12px;border-radius:12px;margin-bottom:12px}
.grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
@media (max-width:980px){ .grid{grid-template-columns:1fr} }

.card{background:transparent;padding:8px;border-radius:10px}
.sectionTitle{font-weight:700;margin-bottom:8px}
.list{margin-top:8px}
.person{padding:10px;border-radius:10px;background:transparent;border-bottom:1px solid #161616;margin-bottom:8px}
.row{display:flex;align-items:center;gap:8px;justify-content:space-between}
.name{font-weight:700}
.badge{padding:6px 10px;border-radius:10px;background:var(--pill);font-weight:700}
.badge.focus{background:var(--accent);color:#001}
.progressWrap{height:12px;background:#111;border-radius:10px;overflow:hidden;margin:8px 0}
.progress{height:100%;background:linear-gradient(90deg,var(--accent),#00f0b0);width:0;transition:width .25s}
.actionRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.actionBtn{background:#111;padding:9px 12px;border-radius:10px;border:1px solid #222;color:#9fcfff;cursor:pointer}
.smallText{color:var(--muted);font-size:13px;margin-top:10px}
.uploader{background:#0b0b0b;padding:12px;border-radius:12px;border:1px dashed #222}
.ocrOutput{white-space:pre-wrap;background:#050505;padding:10px;border-radius:8px;margin-top:8px}
.progressLine{height:8px;background:#222;border-radius:8px;overflow:hidden;margin-top:8px}
.progressFill{height:100%;background:linear-gradient(90deg,#3182ce,#00d18a);width:0;transition:width .15s}
.templateBox{background:#070707;padding:10px;border-radius:8px;margin-top:8px}
.linkBtn{background:#0a84ff;padding:10px;border-radius:10px;color:#fff;text-decoration:none;display:inline-block}
.footer{color:var(--muted);font-size:13px;margin-top:14px}
</style>
</head>
<body>
<div class="wrap">
  <h1>ðŸ”¥ Rizz System â€” Version 1 (Screenshot Rizz)</h1>
  <div class="headerNote">Stable Rizz core + screenshot OCR to extract names/messages and create quick WhatsApp replies. Your images are processed in your browser.</div>

  <div id="banner" class="banner"></div>

  <div class="controls">
    <input id="addName" class="inputText" placeholder="Add person (name) to Rizz system"/>
    <button id="addBtn" class="btn">Add / Update</button>
    <button id="clearBtn" class="btn small">Clear All</button>
    <button id="exportPeople" class="btn small" style="display:none">Export (disabled)</button>
  </div>

  <div class="grid">
    <!-- LEFT: Rizz System -->
    <div>
      <div class="card">
        <div class="sectionTitle">Rizz Dashboard (Version 1 core)</div>
        <div id="rizzList" class="list"></div>
        <div class="smallText">Tip: Auto-focus triggers at 90% and max 2 Focus are enforced. Scores decay every 2 days.</div>
      </div>

      <div class="card" style="margin-top:14px">
        <div class="sectionTitle">Quick Controls</div>
        <div class="actionRow">
          <button id="decayBtn" class="actionBtn">Run Decay (test)</button>
          <button id="autoRankBtn" class="actionBtn">Auto Rank (Top 2)</button>
          <button id="suggestTextBtn" class="actionBtn">Suggest Texts for All</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: Screenshot OCR & Actions -->
    <div>
      <div class="card uploader">
        <div class="sectionTitle">Upload Screenshot</div>
        <input id="screenshotFile" type="file" accept="image/*" />
        <div id="ocrControls" style="margin-top:8px">
          <button id="startOcr" class="btn small">Run OCR</button>
          <button id="clearOcr" class="btn small">Clear</button>
        </div>

        <div id="ocrStatus" class="smallText"></div>
        <div class="progressLine" style="display:none"><div id="ocrProgress" class="progressFill"></div></div>

        <div id="ocrImagePreview" style="margin-top:10px"></div>
        <div id="ocrText" class="ocrOutput" style="display:none"></div>

        <div id="parsedResults" style="margin-top:10px"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <div class="sectionTitle">Reply Templates</div>
        <div id="templatesArea" class="templateBox">No templates yet â€” run OCR on a screenshot or click "Suggest Texts for All".</div>
      </div>
    </div>
  </div>

  <div class="footer">Saved as "Version 1 Rizz" baseline. To connect to WhatsApp the app opens <code>wa.me</code> with your message (you must confirm send).</div>
</div>

<script>
/* ===========================
   Rizz System core (Version 1 baseline)
   - store in localStorage
   - people: { id, name, score (0..100), status:'active'|'paused', focused (bool), focusedAt (ts), lastTickAt (ms) }
   - auto-focus >= 90, max 2 focus (remove oldest)
   - decay computed in steps of 2 days (applied on demand or after actions)
   =========================== */

const STORAGE_KEY = 'rizz_v1_full';
const DECAY_DAYS = 2;
const DECAY_MS = DECAY_DAYS * 24*60*60*1000;
const DECAY_AMOUNT = 10;
const FOCUS_LIMIT = 2;
const AUTO_FOCUS_THRESHOLD = 90;

let rizz = { people: [], lastDecayAt: Date.now() };

// safe load
function loadRizz(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && Array.isArray(parsed.people)) rizz = parsed;
    }
  }catch(e){ console.warn("load failed", e); rizz = { people: [], lastDecayAt: Date.now() }; }
}
function saveRizz(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(rizz)); }

// helpers
const uid = ()=> Math.random().toString(36).slice(2,9);
const now = ()=> Date.now();
const clamp = v => Math.max(0, Math.min(100, Math.round(v || 0)));

function ensurePersonStructure(p){
  p.id = p.id || uid();
  p.name = String(p.name || '').trim();
  p.score = clamp(p.score || 0);
  p.status = p.status || 'active';
  p.focused = !!p.focused;
  p.focusedAt = p.focusedAt || (p.focused ? now() : null);
  p.lastTickAt = p.lastTickAt || now();
  return p;
}

/* Add or update person by name (case-insensitive) */
function addOrUpdatePerson(name){
  name = String(name || '').trim();
  if(!name) return notify("Enter a name to add");
  let found = rizz.people.find(p => p.name.toLowerCase() === name.toLowerCase());
  if(found){
    found.lastTickAt = now(); // refresh timestamp
    notify("Updated " + found.name);
  } else {
    const p = ensurePersonStructure({ id: uid(), name, score: 0, status: 'active', focused: false, focusedAt: null });
    rizz.people.push(p);
    notify("Added " + p.name);
  }
  saveRizz();
  runPostChange();
}

/* Update score safely */
function changeScore(id, delta){
  const p = rizz.people.find(x => x.id === id);
  if(!p) return;
  p.score = clamp(p.score + delta);
  p.lastTickAt = now();
  saveRizz();
  enforceAutoFocus(); // must run after score change
  renderRizz();
}

/* Manual set focus */
function setFocus(id){
  const p = rizz.people.find(x => x.id === id);
  if(!p) return;
  if(!p.focused){
    // if limit reached remove oldest focused
    const focused = rizz.people.filter(x => x.focused).sort((a,b)=> (a.focusedAt||0) - (b.focusedAt||0));
    if(focused.length >= FOCUS_LIMIT){
      const demote = focused[0];
      demote.focused = false;
      demote.focusedAt = null;
      notify("Focus limit reached â€” oldest focus removed");
    }
    p.focused = true;
    p.focusedAt = now();
  } else {
    // unfocus
    p.focused = false;
    p.focusedAt = null;
  }
  p.lastTickAt = now();
  saveRizz();
  renderRizz();
}

/* Pause/resume */
function togglePause(id){
  const p = rizz.people.find(x => x.id === id);
  if(!p) return;
  p.status = (p.status === 'paused') ? 'active' : 'paused';
  // if pausing also unfocus
  if(p.status === 'paused' && p.focused){
    p.focused = false;
    p.focusedAt = null;
  }
  p.lastTickAt = now();
  saveRizz();
  renderRizz();
}

/* Remove */
function removePerson(id){
  const p = rizz.people.find(x => x.id === id);
  if(!p) return;
  rizz.people = rizz.people.filter(x => x.id !== id);
  saveRizz();
  notify("Deleted " + p.name);
  renderRizz();
}

/* Enforce auto-focus logic:
   - any person with score >= AUTO_FOCUS_THRESHOLD & not paused becomes focused
   - if focus limit exceeded, remove oldest focused (by focusedAt)
*/
function enforceAutoFocus(){
  const candidates = rizz.people.filter(p => p.score >= AUTO_FOCUS_THRESHOLD && !p.focused && p.status !== 'paused');
  if(candidates.length === 0) return;
  candidates.forEach(p => {
    // remove oldest if needed
    const focusedNow = rizz.people.filter(x => x.focused).sort((a,b)=> (a.focusedAt||0) - (b.focusedAt||0));
    if(focusedNow.length >= FOCUS_LIMIT){
      const dem = focusedNow[0];
      dem.focused = false;
      dem.focusedAt = null;
      notify("Focus limit reached â€” oldest focus removed");
    }
    p.focused = true;
    p.focusedAt = now();
    notify("Auto-Focus: " + p.name);
  });
  saveRizz();
  renderRizz();
}

/* Decay: compute how many 2-day periods passed since lastDecayAt and apply */
function runDecay(force=false){
  const last = rizz.lastDecayAt || now();
  const msPerPeriod = DECAY_MS;
  const elapsed = now() - last;
  const steps = force ? 1 : Math.floor(elapsed / msPerPeriod);
  if(steps <= 0 && !force) return;
  rizz.people.forEach(p => {
    if(p.focused) return; // skip focused
    if(p.status === 'paused') return; // skip paused
    const total = DECAY_AMOUNT * steps;
    if(total > 0){
      p.score = clamp(p.score - total);
    }
  });
  rizz.lastDecayAt = force ? now() : (last + steps * msPerPeriod);
  saveRizz();
  enforceAutoFocus();
  renderRizz();
  notify("Decay applied (" + (steps || 1) + " step(s))");
}

/* Run checks after user actions */
function runPostChange(){
  runDecay();           // apply any due decay
  enforceAutoFocus();   // auto-focus those who hit threshold
  renderRizz();
}

/* UI render for Rizz list */
function renderRizz(){
  loadRizz(); // ensure latest
  const list = document.getElementById('rizzList');
  list.innerHTML = '';
  if(rizz.people.length === 0){
    list.innerHTML = '<div class="smallText" style="color:var(--muted)">No people yet. Add names manually or from screenshot.</div>';
    return;
  }
  // sort: focused first (recent) then score desc
  const sorted = [...rizz.people].sort((a,b) => {
    const af = !!a.focused, bf = !!b.focused;
    if(af !== bf) return af ? -1 : 1;
    if(b.score !== a.score) return b.score - a.score;
    return a.name.localeCompare(b.name);
  });

  sorted.forEach(p => {
    const div = document.createElement('div');
    div.className = 'person';
    div.innerHTML = `
      <div class="row">
        <div><div class="name">${escapeHtml(p.name)} â€” ${p.score}%</div></div>
        <div><span class="badge ${p.focused ? 'focus' : ''}">${p.focused ? 'FOCUS' : (p.status === 'paused' ? 'PAUSED' : 'ACTIVE')}</span></div>
      </div>
      <div class="progressWrap"><div class="progress" style="width:${p.score}%"></div></div>
      <div class="actionRow">
        <button class="actionBtn" onclick="changeScoreBy('${p.id}', -10)">-10</button>
        <button class="actionBtn" onclick="changeScoreBy('${p.id}', +10)">+10</button>
        <button class="actionBtn" onclick="setFocus('${p.id}')">${p.focused ? 'Unfocus' : 'Focus'}</button>
        <button class="actionBtn" onclick="togglePause('${p.id}')">${p.status === 'paused' ? 'Resume' : 'Pause'}</button>
        <button class="actionBtn" onclick="removePerson('${p.id}')">Delete</button>
      </div>
    `;
    list.appendChild(div);
  });
}

/* Small wrappers used by render action buttons */
function changeScoreBy(id, delta){ changeScore(id, delta); }

/* escape html */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* notify helper */
function notify(msg){ const b = document.getElementById('banner'); b.style.display = 'block'; b.textContent = msg; clearTimeout(b._t); b._t = setTimeout(()=> b.style.display = 'none', 3000); }

/* ===========================
   Screenshot OCR and parsing
   Uses Tesseract.js loaded from CDN
   - Accept an image file
   - Run OCR in browser
   - Show raw text and quick parsed results
   - Offer "Add detected names" buttons to add to Rizz
   - Offer suggested WhatsApp reply templates with one-click to open wa.me
   =========================== */

const fileInput = document.getElementById('screenshotFile');
const startOcrBtn = document.getElementById('startOcr');
const clearOcrBtn = document.getElementById('clearOcr');
const ocrStatus = document.getElementById('ocrStatus');
const ocrTextEl = document.getElementById('ocrText');
const ocrPreview = document.getElementById('ocrImagePreview');
const parsedResults = document.getElementById('parsedResults');
const templatesArea = document.getElementById('templatesArea');
const ocrProgressBar = document.querySelector('.progressLine');
const ocrProgressFill = document.getElementById('ocrProgress');

let currentImageDataUrl = null;
let lastOcrText = '';

function resetOcrUI(){
  ocrStatus.textContent = '';
  ocrTextEl.style.display = 'none';
  ocrTextEl.textContent = '';
  ocrPreview.innerHTML = '';
  parsedResults.innerHTML = '';
  templatesArea.innerHTML = 'No templates yet â€” run OCR on a screenshot or click "Suggest Texts for All".';
  if(ocrProgressBar) ocrProgressBar.style.display = 'none';
  if(ocrProgressFill) ocrProgressFill.style.width = '0%';
  currentImageDataUrl = null;
  lastOcrText = '';
}

/* display preview */
fileInput.addEventListener('change', e=>{
  resetOcrUI();
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = document.createElement('img');
  img.style.maxWidth = '100%';
  img.style.borderRadius = '8px';
  img.src = url;
  ocrPreview.innerHTML = '';
  ocrPreview.appendChild(img);
  currentImageDataUrl = url;
  ocrStatus.textContent = 'Ready to OCR â€” press "Run OCR".';
});

/* Run OCR using Tesseract */
startOcrBtn.addEventListener('click', async ()=>{
  if(!currentImageDataUrl) return notify('Upload a screenshot first');
  ocrStatus.textContent = 'Starting OCR...';
  ocrTextEl.style.display = 'none';
  parsedResults.innerHTML = '';
  templatesArea.innerHTML = '';
  if(ocrProgressBar) ocrProgressBar.style.display = 'block';
  try{
    const worker = Tesseract.createWorker({
      logger: m => {
        if(m.status === 'recognizing text' && m.progress){
          const pct = Math.round(m.progress * 100);
          if(ocrProgressFill) ocrProgressFill.style.width = pct + '%';
          ocrStatus.textContent = `OCR progress: ${pct}%`;
        } else {
          ocrStatus.textContent = m.status || 'Working...';
        }
      }
    });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    const { data } = await worker.recognize(currentImageDataUrl);
    await worker.terminate();
    lastOcrText = data && data.text ? data.text.trim() : '';
    ocrTextEl.style.display = 'block';
    ocrTextEl.textContent = lastOcrText || '[No text recognized â€” try a clearer screenshot]';
    ocrStatus.textContent = 'OCR finished';
    parseOcrText(lastOcrText);
  }catch(err){
    console.error(err);
    ocrStatus.textContent = 'OCR failed: ' + (err.message || err);
    ocrTextEl.style.display = 'block';
    ocrTextEl.textContent = 'OCR error: ' + (err.message || String(err));
    if(ocrProgressBar) ocrProgressBar.style.display = 'none';
  }
});

/* Clear OCR UI */
clearOcrBtn.addEventListener('click', ()=> {
  fileInput.value = '';
  resetOcrUI();
});

/* Parse OCR text heuristically */
function parseOcrText(text){
  parsedResults.innerHTML = '';
  templatesArea.innerHTML = '';
  if(!text || !text.trim()){
    parsedResults.innerHTML = '<div class="smallText">No text parsed.</div>';
    return;
  }

  // 1) extract phone numbers (simple regex)
  const phoneRegex = /(\+?\d{8,15})/g;
  const phones = [...new Set((text.match(phoneRegex) || []))];

  // 2) extract candidate names: capitalized words or pairs (heuristic)
  const words = text.split(/\s+/).filter(Boolean);
  const nameCandidates = [];
  for(let i=0;i<words.length;i++){
    const w = words[i].replace(/[^A-Za-z\-]/g,'');
    if(w.length>=2 && /^[A-Z][a-z]+$/.test(w)){
      // try pair (First Last)
      const nxt = (words[i+1]||'').replace(/[^A-Za-z\-]/g,'');
      if(nxt && /^[A-Z][a-z]+$/.test(nxt)){
        nameCandidates.push(w + ' ' + nxt);
      } else {
        nameCandidates.push(w);
      }
    }
  }
  const names = [...new Set(nameCandidates)].slice(0,8);

  // 3) times (like 7:00, 1:00am, 13:00)
  const timeRegex = /(\b(?:[01]?\d|2[0-3]):[0-5]\d(?:\s?(?:am|pm))?\b)/gi;
  const times = [...new Set((text.match(timeRegex) || []))];

  // 4) short message snippets: pull lines that look like messages (short lines)
  const lines = text.split(/\n/).map(l=>l.trim()).filter(Boolean);
  const snippets = lines.filter(l=> l.length < 160).slice(0,8);

  // Build UI
  let html = '<div class="sectionTitle">Detected</div>';
  if(names.length){
    html += '<div><strong>Names:</strong></div>';
    names.forEach(n => {
      html += `<div style="margin:6px 0">
        <span style="display:inline-block;background:#111;padding:6px 8px;border-radius:8px;margin-right:8px">${escapeHtml(n)}</span>
        <button class="actionBtn" onclick="addDetectedName(${JSON.stringify(n)})">Add to Rizz</button>
      </div>`;
    });
  }
  if(phones.length){
    html += '<div style="margin-top:8px"><strong>Phones:</strong></div>';
    phones.forEach(ph => {
      html += `<div style="margin:6px 0"><span style="display:inline-block;background:#111;padding:6px 8px;border-radius:8px;margin-right:8px">${escapeHtml(ph)}</span></div>`;
    });
  }
  if(times.length){
    html += '<div style="margin-top:8px"><strong>Times found:</strong> ${escapeHtml(times.join(', '))}</div>';
  }
  if(snippets.length){
    html += '<div style="margin-top:8px"><strong>Message snippets:</strong></div>';
    snippets.forEach(s => {
      html += `<div style="margin:6px 0;padding:8px;background:#050505;border-radius:8px">${escapeHtml(s)}</div>`;
    });
  }
  parsedResults.innerHTML = html;

  // Extract templates (simple)
  const templates = generateTemplatesFromText(text, names, snippets);
  renderTemplates(templates);
}

/* Called by parsed UI */
function addDetectedName(name){
  addOrUpdatePerson(name);
}

/* Generate a few quick templates based on parsed text and detected names */
function generateTemplatesFromText(text, names, snippets){
  const templates = [];
  const baseSnippet = snippets.length ? snippets[0] : (text.split('\n').find(Boolean) || 'Hey');
  // Generic templates
  templates.push({ title: 'Short playful', text: `Hey ${names[0]||''}! I saw your message â€” you good? ðŸ˜Š` });
  templates.push({ title: 'Smooth check-in', text: `Hello ${names[0]||''}, hope youâ€™re well. About your message: ${baseSnippet}` });
  templates.push({ title: 'Set meet', text: `Hi ${names[0]||''}. I can help. When are you free?` });
  templates.push({ title: 'Ask for details', text: `Hey, saw this: "${baseSnippet}". Can you send more details?` });
  // If time found, add schedule template
  const timeMatch = text.match(/([01]?\d|2[0-3]):[0-5]\d(?:\s?(?:am|pm))?/i);
  if(timeMatch){
    templates.push({ title: 'Confirm time', text: `Okay ${names[0]||''}, let's meet at ${timeMatch[0]}. Does that work?` });
  }
  return templates.slice(0,6);
}

function renderTemplates(templates){
  if(!templates || !templates.length){
    templatesArea.innerHTML = 'No templates generated.';
    return;
  }
  let html = '';
  templates.forEach((t, i) => {
    html += `<div style="margin-bottom:8px">
      <div style="font-weight:700">${escapeHtml(t.title)}</div>
      <div style="margin:6px 0">${escapeHtml(t.text)}</div>
      <div>
        <button class="actionBtn" onclick="copyTemplateText(${JSON.stringify(t.text)})">Copy</button>
        <a class="linkBtn" href="${makeWhatsAppLink(t.text)}" target="_blank" rel="noopener">Open WhatsApp</a>
      </div>
    </div>`;
  });
  templatesArea.innerHTML = html;
}

/* Copy text to clipboard */
function copyTemplateText(t){
  navigator.clipboard?.writeText(t).then(()=> notify('Copied to clipboard'), ()=> notify('Copy failed'));
}

/* Construct wa.me link (prefill only) */
function makeWhatsAppLink(text){
  const encoded = encodeURIComponent(text);
  return `https://wa.me/?text=${encoded}`;
}

/* ===========================
   Hook UI controls and boot
   =========================== */
function addOrUpdatePersonFromInput(){
  const val = document.getElementById('addName').value.trim();
  if(!val) return notify('Type a name to add');
  addOrUpdatePerson(val);
  document.getElementById('addName').value = '';
}

document.getElementById('addBtn').addEventListener('click', addOrUpdatePersonFromInput);
document.getElementById('clearBtn').addEventListener('click', ()=> {
  if(confirm('Clear all Rizz people?')) { rizz.people = []; rizz.lastDecayAt = now(); saveRizz(); renderRizz(); notify('Cleared all'); }
});
document.getElementById('decayBtn').addEventListener('click', ()=> runDecay(true));
document.getElementById('autoRankBtn').addEventListener('click', ()=> {
  // quick rank: sort and focus top two
  rizz.people.sort((a,b)=> b.score - a.score);
  rizz.people.forEach((p,i)=> { p.focused = (i < FOCUS_LIMIT); p.focusedAt = p.focused ? now() : null; });
  saveRizz();
  renderRizz();
  notify('Auto-rank applied');
});
document.getElementById('suggestTextBtn').addEventListener('click', ()=> {
  const templates = [];
  rizz.people.forEach(p => {
    templates.push({ title: `Text for ${p.name}`, text: `Hey ${p.name}, how are you?` });
  });
  renderTemplates(templates);
});

/* OCR: wire start button (uses Tesseract.js) */
startOcrBtn.addEventListener('click', async ()=>{
  if(!fileInput.files || !fileInput.files[0]) return notify('Choose an image file first');
  parsedResults.innerHTML = '';
  templatesArea.innerHTML = '';
  ocrTextEl.style.display = 'none';
  ocrStatus.textContent = 'Initializing OCR...';
  if(ocrProgressBar) ocrProgressBar.style.display = 'block';
  try{
    const worker = Tesseract.createWorker({
      logger: m => {
        // update progress
        if(m.status === 'recognizing text' && typeof m.progress === 'number'){
          const pct = Math.round(m.progress * 100);
          if(ocrProgressFill) ocrProgressFill.style.width = pct + '%';
          ocrStatus.textContent = `OCR ${pct}%`;
        } else {
          ocrStatus.textContent = m.status || '';
        }
      }
    });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    const { data } = await worker.recognize(fileInput.files[0]);
    await worker.terminate();
    lastOcrText = data.text || '';
    ocrTextEl.style.display = 'block';
    ocrTextEl.textContent = lastOcrText;
    ocrStatus.textContent = 'OCR Done';
    parseOcrText(lastOcrText);
  }catch(err){
    console.error(err);
    ocrStatus.textContent = 'OCR error: ' + (err.message || err);
    ocrTextEl.style.display = 'block';
    ocrTextEl.textContent = 'OCR failed';
  } finally {
    if(ocrProgressBar) ocrProgressBar.style.display = 'none';
    if(ocrProgressFill) ocrProgressFill.style.width = '0%';
  }
});

/* helpers used by parsed UI functions (expose) */
window.addDetectedName = name => addDetectedName(name);
window.copyTemplateText = t => copyTemplateText(t);
window.makeWhatsAppLink = t => makeWhatsAppLink(t);

/* init store and render */
loadRizz();
runPostChange(); // applies decay if needed + autoselect
renderRizz();
resetOcrUI();

</script>
</body>
</html>
